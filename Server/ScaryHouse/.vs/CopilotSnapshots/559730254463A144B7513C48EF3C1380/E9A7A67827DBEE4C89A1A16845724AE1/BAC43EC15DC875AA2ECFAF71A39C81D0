using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ScaryHouse
{
    public partial class Form1 : Form
    {
        private const int NodesPerGroup = 10;
        private List<Label> batteryLabels = new List<Label>();
        private List<CirclePanel> nodeLights = new List<CirclePanel>();
        private SimpleMqttClient mqttClient;
        private bool userRequestedDisconnect = false;
        private RoomConfig roomConfig;
        private DataGridView statusGrid;

        // mappings: groupIndex (1..3) -> mac(no colons) -> slot index (0..9)
        private Dictionary<int, Dictionary<string, int>> groupMappings = new Dictionary<int, Dictionary<string, int>>();
        private Dictionary<string, DateTime> lastSeen = new Dictionary<string, DateTime>();
        private Dictionary<string, int> lastBattery = new Dictionary<string, int>();
        private Dictionary<string, bool> isOnline = new Dictionary<string, bool>();
        private TimeSpan offlineTimeout; // will initialize from numericTimeout

        // New: track which maingate was last activated and per-group set of eachgate numbers already handled
        private int lastActiveMainGate = 0; // 0 = none, 1..3 = groups
        private Dictionary<int, HashSet<int>> groupActivatedEachGates = new Dictionary<int, HashSet<int>>();

        // Activation order and lag policy
        private Dictionary<int, int> activationOrder = new Dictionary<int, int>(); // group -> order (1 = first)
        private int activationCounter = 0;
        private const int Lag = 3; // leader must be ahead by at least this many gates

        // ensure play publish happens only once per group
        private Dictionary<int, bool> playPublished = new Dictionary<int, bool>();

        public Form1()
        {
            InitializeComponent();

            groupMappings[1] = new Dictionary<string, int>();
            groupMappings[2] = new Dictionary<string, int>();
            groupMappings[3] = new Dictionary<string, int>();

            // initialize per-group activated eachgate sets
            groupActivatedEachGates[1] = new HashSet<int>();
            groupActivatedEachGates[2] = new HashSet<int>();
            groupActivatedEachGates[3] = new HashSet<int>();

            // initialize playPublished flags
            playPublished[1] = false; playPublished[2] = false; playPublished[3] = false;

            roomConfig = RoomConfig.Load();

            try { offlineTimeout = TimeSpan.FromSeconds((double)numericTimeout.Value); }
            catch { offlineTimeout = TimeSpan.FromSeconds(20); }

            // theme styling
            this.BackColor = Color.FromArgb(30, 30, 30);
            this.ForeColor = Color.White;

            flowControls.BackColor = Color.FromArgb(45, 45, 48);
            flowControls.ForeColor = Color.White;

            foreach (Control c in flowControls.Controls)
            {
                if (c is Button b)
                {
                    b.FlatStyle = FlatStyle.Flat;
                    b.UseVisualStyleBackColor = false;
                    b.BackColor = Color.FromArgb(63, 63, 70);
                    b.ForeColor = Color.White;
                }
            }
        }

        private async void Form1_Load(object sender, EventArgs e)
        {
            CreateNodeControls(flowGroup1, 1);
            CreateNodeControls(flowGroup2, 2);
            CreateNodeControls(flowGroup3, 3);

            CreateStatusGrid();

            timer1.Start();

            try
            {
                var localIp = GetLocalWifiIpv4();
                if (!string.IsNullOrWhiteSpace(localIp)) textBoxBroker.Text = localIp;
            }
            catch { }

            await SetupMqttClient();
        }

        private string GetLocalWifiIpv4()
        {
            try
            {
                foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    if (ni.NetworkInterfaceType == NetworkInterfaceType.Wireless80211 && ni.OperationalStatus == OperationalStatus.Up)
                    {
                        var uni = ni.GetIPProperties().UnicastAddresses.FirstOrDefault(a => a.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork);
                        if (uni != null) return uni.Address.ToString();
                    }
                }

                foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    if (ni.OperationalStatus != OperationalStatus.Up) continue;
                    var uni = ni.GetIPProperties().UnicastAddresses.FirstOrDefault(a => a.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork);
                    if (uni != null) return uni.Address.ToString();
                }
            }
            catch { }
            return null;
        }

        private void CreateNodeControls(FlowLayoutPanel panel, int groupNumber)
        {
            panel.AutoScroll = true;
            panel.FlowDirection = FlowDirection.TopDown;
            panel.WrapContents = false;
            panel.Padding = new Padding(8);
            panel.BackColor = Color.FromArgb(40, 40, 40);

            var header = new Label()
            {
                Text = $"Group {groupNumber}",
                AutoSize = false,
                Width = panel.ClientSize.Width - 20,
                Height = 34,
                TextAlign = ContentAlignment.MiddleCenter,
                Font = new Font("Segoe UI", 12F, FontStyle.Bold),
                ForeColor = Color.White,
                BackColor = Color.FromArgb(28, 151, 234)
            };
            panel.Controls.Add(header);

            for (int i = 0; i < NodesPerGroup; i++)
            {
                var container = new Panel { Width = panel.ClientSize.Width - 25, Height = 48, BackColor = Color.FromArgb(50, 50, 52), Margin = new Padding(3, 6, 3, 6) };
                var light = new CirclePanel { Width = 28, Height = 28, Left = 8, Top = 10, FillColor = Color.Red };
                var lbl = new Label { AutoSize = false, Width = container.Width - 48, Left = 44, Top = 8, Height = 18, Font = new Font("Segoe UI", 9F), ForeColor = Color.White, Text = $"HeadSet {i + 1}: -- | Battery: --%" };
                var macLabel = new Label { AutoSize = false, Width = container.Width - 48, Left = 44, Top = 26, Height = 14, Font = new Font("Consolas", 8F), ForeColor = Color.LightGray, Text = "MAC: --" };

                container.Controls.Add(light);
                container.Controls.Add(lbl);
                container.Controls.Add(macLabel);
                panel.Controls.Add(container);

                nodeLights.Add(light);
                batteryLabels.Add(lbl);
            }
        }

        private void CreateStatusGrid()
        {
            statusGrid = new DataGridView { Dock = DockStyle.Bottom, Height = 160, ReadOnly = true, AllowUserToAddRows = false, RowHeadersVisible = false };
            statusGrid.EnableHeadersVisualStyles = false;
            statusGrid.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;

            statusGrid.ColumnHeadersDefaultCellStyle.BackColor = Color.FromArgb(45, 45, 48);
            statusGrid.ColumnHeadersDefaultCellStyle.ForeColor = Color.White;
            statusGrid.ColumnHeadersDefaultCellStyle.Font = new Font("Segoe UI", 9F, FontStyle.Bold);
            statusGrid.DefaultCellStyle.SelectionBackColor = Color.DarkOrange;
            statusGrid.DefaultCellStyle.SelectionForeColor = Color.White;

            statusGrid.Columns.Clear();
            statusGrid.Columns.Add("colGroup", "Group");
            statusGrid.Columns[0].Width = 80;
            statusGrid.Columns.Add("colMain", "maingate");
            statusGrid.Columns[1].Width = 70;
            for (int i = 1; i <= 15; i++)
            {
                var name = i.ToString("D2");
                statusGrid.Columns.Add("col" + name, name);
                statusGrid.Columns[statusGrid.Columns.Count - 1].Width = 40;
            }

            statusGrid.Rows.Clear();
            for (int r = 1; r <= 3; r++)
            {
                int idx = statusGrid.Rows.Add();
                statusGrid.Rows[idx].Cells[0].Value = "Group " + r;
                statusGrid.Rows[idx].Cells[0].Style.BackColor = Color.FromArgb(45, 45, 48);
                statusGrid.Rows[idx].Cells[0].Style.ForeColor = Color.White;
                statusGrid.Rows[idx].Cells[0].Style.Font = new Font("Segoe UI", 9F, FontStyle.Bold);
            }

            ResetStatusGridColors();

            this.Controls.Add(statusGrid);
            statusGrid.BringToFront();
        }

        private void ResetStatusGridColors()
        {
            if (statusGrid == null) return;
            Invoke(new Action(() =>
            {
                for (int r = 0; r < statusGrid.Rows.Count; r++)
                {
                    for (int c = 1; c < statusGrid.Columns.Count; c++)
                    {
                        statusGrid.Rows[r].Cells[c].Style.BackColor = Color.Red;
                        statusGrid.Rows[r].Cells[c].Style.ForeColor = Color.White;
                        statusGrid.Rows[r].Cells[c].Value = null;
                    }
                }
            }));
        }

        private async Task SetupMqttClient()
        {
            try
            {
                if (mqttClient != null)
                {
                    try { await mqttClient.DisconnectAsync(); } catch { }
                    mqttClient = null;
                }

                string host = textBoxBroker.Text;

                mqttClient = new SimpleMqttClient();
                mqttClient.MessageReceived += MqttClient_MessageReceived;
                mqttClient.Disconnected += MqttClient_Disconnected;

                await mqttClient.ConnectAsync(host, 1883, "ScaryHouseClient");

                // subscribe to status topics including maindoor and eachgate
                await mqttClient.SubscribeAsync(new[] { "status/group1", "status/group2", "status/group3", "status/maindoor", "status/eachgate" });

                Invoke(new Action(() => buttonConnect.Text = "Connected"));
                Logger.Log($"Connected to MQTT broker {host}");
            }
            catch (Exception ex)
            {
                MessageBox.Show("MQTT connect failed: " + ex.Message);
                Invoke(new Action(() => buttonConnect.Text = "Connect MQTT"));
                Logger.Log($"MQTT connect failed: {ex.Message}");
            }
        }

        private void MqttClient_Disconnected(Exception ex)
        {
            Invoke(new Action(() => buttonConnect.Text = "Connect MQTT"));
            Logger.Log($"Disconnected from MQTT broker: {ex?.Message ?? "unknown"}");

            if (userRequestedDisconnect) return;

            string host = textBoxBroker.Text;
            _ = Task.Run(async () =>
            {
                while (!userRequestedDisconnect)
                {
                    try
                    {
                        var client = new SimpleMqttClient();
                        client.MessageReceived += MqttClient_MessageReceived;
                        client.Disconnected += MqttClient_Disconnected;
                        await client.ConnectAsync(host, 1883, "ScaryHouseClient");
                        await client.SubscribeAsync(new[] { "status/group1", "status/group2", "status/group3", "status/maindoor", "status/eachgate" });

                        var old = mqttClient; mqttClient = client; try { old?.Dispose(); } catch { }
                        Invoke(new Action(() => buttonConnect.Text = "Connected"));
                        Logger.Log($"Reconnected to MQTT broker {host}");
                        break;
                    }
                    catch { await Task.Delay(5000); }
                }
            });
        }

        // helper: next expected eachgate number for a group (1..15), or -1 if none
        private int GetNextExpectedForGroup(int group)
        {
            if (!groupActivatedEachGates.TryGetValue(group, out var set)) return 1;
            for (int i = 1; i <= 15; i++) if (!set.Contains(i)) return i;
            return -1;
        }

        private void HandleMainDoorMessage(string payload)
        {
            // payload expected 2-digit switch number "00","01","02","03"
            if (string.IsNullOrWhiteSpace(payload) || payload.Length < 2) return;
            var val = payload.Trim();
            if (val == "00") return; // heartbeat
            if (!int.TryParse(val, out int switchNum)) return;
            if (switchNum < 1 || switchNum > 3) return;

            int row = switchNum - 1; // map 1->row0,2->row1,3->row2
            int col = 1; // maingate column index

            // mark green (persistent until reset)
            MarkGridCellPersistent(row, col);

            // update last active maingate so subsequent eachgate messages are applied to this group
            lastActiveMainGate = switchNum;

            // record activation order if first time
            if (!activationOrder.ContainsKey(switchNum))
            {
                activationCounter++;
                activationOrder[switchNum] = activationCounter;
            }

            Logger.Log($"MainDoor switch {val} pressed -> Group {row + 1} maingate");
        }

        private void HandleEachGateMessage(string payload)
        {
            if (string.IsNullOrWhiteSpace(payload) || payload.Length < 2) return;
            var val = payload.Trim();
            if (!int.TryParse(val, out int gateNum)) return;
            if (gateNum < 1 || gateNum > 15) return;

            // Determine which group should receive this eachgate event.
            // Priority: if lastActiveMainGate expects this gateNum -> use it.
            // Otherwise, find any group whose next expected equals gateNum.
            int targetGroup = -1;

            if (lastActiveMainGate >= 1 && lastActiveMainGate <= 3)
            {
                int next = GetNextExpectedForGroup(lastActiveMainGate);
                if (next == gateNum) targetGroup = lastActiveMainGate;
            }

            if (targetGroup == -1)
            {
                for (int g = 1; g <= 3; g++)
                {
                    int next = GetNextExpectedForGroup(g);
                    if (next == gateNum) { targetGroup = g; break; }
                }
            }

            if (targetGroup == -1)
            {
                Logger.Log($"EachGate event {val} ignored - no group expects gate {gateNum}");
                return;
            }

            var set = groupActivatedEachGates[targetGroup];
            if (set.Contains(gateNum))
            {
                Logger.Log($"EachGate {val} for Group {targetGroup} ignored - already activated");
                return;
            }

            // Enforce fixed lag policy: leader must be ahead by at least Lag gates
            // Determine current leader (earliest activationOrder)
            int leaderGroup = -1;
            if (activationOrder.Count > 0)
            {
                leaderGroup = activationOrder.OrderBy(kv => kv.Value).First().Key;
            }

            if (leaderGroup != -1 && leaderGroup != targetGroup)
            {
                int leaderProgress = GetNextExpectedForGroup(leaderGroup) - 1; // activated count
                int followerProgress = GetNextExpectedForGroup(targetGroup) - 1;
                if (leaderProgress - followerProgress < Lag)
                {
                    Logger.Log($"EachGate {val} for Group {targetGroup} denied - leader Group {leaderGroup} progress {leaderProgress} too close to follower {followerProgress}");
                    return;
                }
            }

            // mark persistent for target group only
            int row = targetGroup - 1;
            int col = 1 + gateNum; // columns: 0=Group,1=maingate,2=01,...
            MarkGridCellPersistent(row, col);

            // remember that this eachgate has been activated for this group
            set.Add(gateNum);

            // If this is gate 1, schedule one-time delayed publish for this group
            if (gateNum == 1)
            {
                if (!playPublished.TryGetValue(targetGroup, out bool published) || !published)
                {
                    playPublished[targetGroup] = true; // ensure single scheduling
                    int delaySeconds = 20; // default
                    try { if (roomConfig?.RoomSeconds != null && roomConfig.RoomSeconds.Count >= gateNum) delaySeconds = roomConfig.RoomSeconds[gateNum - 1]; } catch { }

                    // schedule background publish
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await Task.Delay(delaySeconds * 1000);
                            string roomNo = gateNum.ToString("D2");
                            string pubPayload = $"play,{roomNo}";
                            string topic = $"music/group{targetGroup}";
                            await PublishIfConnected(topic, pubPayload, false);
                            Logger.Log($"Published scheduled play for Group {targetGroup} room {roomNo}");
                        }
                        catch (Exception ex)
                        {
                            Logger.Log($"Scheduled publish failed: {ex.Message}");
                        }
                    });
                }
            }

            Logger.Log($"EachGate event gate {val} applied to Group {targetGroup}");
        }

        private void MarkGridCellPersistent(int row, int col)
        {
            if (statusGrid == null) return;
            if (row < 0 || row >= statusGrid.Rows.Count) return;
            if (col < 1 || col >= statusGrid.Columns.Count) return;

            Invoke(new Action(() =>
            {
                var cell = statusGrid.Rows[row].Cells[col];
                cell.Style.BackColor = Color.LimeGreen;
                cell.Style.ForeColor = Color.Black;
                cell.Value = null; // keep no text
            }));
        }

        private void numericTimeout_ValueChanged(object sender, EventArgs e)
        {
            try { offlineTimeout = TimeSpan.FromSeconds((double)numericTimeout.Value); } catch { }
        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            var now = DateTime.UtcNow;
            foreach (var kv in lastSeen.ToList())
            {
                if (now - kv.Value > offlineTimeout)
                {
                    var mac = kv.Key;
                    int battery = lastBattery.ContainsKey(mac) ? lastBattery[mac] : 0;
                    for (int g = 1; g <= 3; g++)
                    {
                        if (groupMappings[g].TryGetValue(mac, out int slot))
                        {
                            int globalIndex = (g - 1) * NodesPerGroup + slot;
                            if (globalIndex >= 0 && globalIndex < nodeLights.Count)
                            {
                                nodeLights[globalIndex].FillColor = Color.Red;
                                batteryLabels[globalIndex].Text = $"HeadSet {slot + 1}: Battery: {battery}% (offline)";
                                nodeLights[globalIndex].Invalidate();

                                if (isOnline.TryGetValue(mac, out bool wasOnline) && wasOnline)
                                {
                                    isOnline[mac] = false;
                                    Logger.Log($"Device {mac} Group {g} HeadSet {slot + 1} OFFLINE battery {battery}%");
                                }
                            }
                        }
                    }
                }
            }
        }

        private void MqttClient_MessageReceived(string topic, byte[] payload)
        {
            try
            {
                string payloadStr = Encoding.UTF8.GetString(payload);

                // table topics
                if (topic.EndsWith("maindoor", StringComparison.InvariantCultureIgnoreCase)) { HandleMainDoorMessage(payloadStr); return; }
                if (topic.EndsWith("eachgate", StringComparison.InvariantCultureIgnoreCase)) { HandleEachGateMessage(payloadStr); return; }

                // expected format: mac,battery
                var parts = payloadStr.Split(new[] { ',', ';', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length < 2) return;
                string mac = parts[0].Trim(); if (mac.Contains(":")) mac = mac.Replace(":", ""); if (mac.Length == 0) return;
                if (!int.TryParse(parts[1], out int battery)) battery = 0;

                int group = 0;
                if (topic.EndsWith("group1", StringComparison.InvariantCultureIgnoreCase)) group = 1;
                else if (topic.EndsWith("group2", StringComparison.InvariantCultureIgnoreCase)) group = 2;
                else if (topic.EndsWith("group3", StringComparison.InvariantCultureIgnoreCase)) group = 3;
                if (group == 0) return;

                // Reject if same MAC in other group
                for (int g = 1; g <= 3; g++) if (g != group && groupMappings[g].ContainsKey(mac)) { Logger.Log($"Rejected status from {mac} for group {group} - already assigned to group {g}"); return; }

                // assign slot if new
                if (!groupMappings[group].TryGetValue(mac, out int slotIndex))
                {
                    var used = new HashSet<int>(groupMappings[group].Values);
                    int found = -1;
                    for (int i = 0; i < NodesPerGroup; i++) if (!used.Contains(i)) { found = i; break; }
                    if (found == -1) return;
                    slotIndex = found; groupMappings[group][mac] = slotIndex;
                }

                // update last seen and battery
                lastSeen[mac] = DateTime.UtcNow; lastBattery[mac] = battery;

                int globalIndex = (group - 1) * NodesPerGroup + slotIndex;
                if (globalIndex >= 0 && globalIndex < nodeLights.Count)
                {
                    bool wasOnline = false; isOnline.TryGetValue(mac, out wasOnline);
                    Invoke(new Action(() =>
                    {
                        nodeLights[globalIndex].FillColor = Color.LimeGreen; nodeLights[globalIndex].Invalidate();
                        batteryLabels[globalIndex].Text = $"HeadSet {slotIndex + 1}: Battery: {battery}%";
                        try { var parent = batteryLabels[globalIndex].Parent; var macLbl = parent.Controls.OfType<Label>().Skip(1).FirstOrDefault(); if (macLbl != null) macLbl.Text = "MAC: " + mac; } catch { }
                    }));

                    if (!wasOnline) { isOnline[mac] = true; Logger.Log($"Device {mac} Group {group} HeadSet {slotIndex + 1} ONLINE battery {battery}%"); }
                }
            }
            catch { }
        }

        private async void buttonConnect_Click(object sender, EventArgs e)
        {
            if (mqttClient != null && mqttClient.IsConnected)
            {
                userRequestedDisconnect = true; await mqttClient.DisconnectAsync(); userRequestedDisconnect = false; buttonConnect.Text = "Connect MQTT"; return;
            }
            await SetupMqttClient();
        }

        private void buttonUpdateConfig_Click(object sender, EventArgs e)
        {
            using (var dlg = new RoomSettingsForm(roomConfig))
            {
                if (dlg.ShowDialog(this) == DialogResult.OK)
                {
                    Logger.Log("Room timers updated"); MessageBox.Show("Room timers saved");
                }
            }
        }

        // Add missing pub handlers (wired in designer)
        private async void buttonPub1_Click(object sender, EventArgs e) => await PublishIfConnected("music/group1", "play");
        private async void buttonPub2_Click(object sender, EventArgs e) => await PublishIfConnected("music/group2", "play");
        private async void buttonPub3_Click(object sender, EventArgs e) => await PublishIfConnected("music/group3", "play");

        private async Task PublishIfConnected(string topic, string payload, bool showMessage = true)
        {
            if (mqttClient == null || !mqttClient.IsConnected) { if (showMessage) MessageBox.Show("Not connected to MQTT broker"); return; }
            try { await mqttClient.PublishAsync(topic, Encoding.UTF8.GetBytes(payload)); if (showMessage) MessageBox.Show($"Published to {topic}"); }
            catch (Exception ex) { if (showMessage) MessageBox.Show("Publish failed: " + ex.Message); }
        }

        private void buttonReset_Click(object sender, EventArgs e)
        {
            groupMappings[1].Clear(); groupMappings[2].Clear(); groupMappings[3].Clear(); lastSeen.Clear(); lastBattery.Clear(); isOnline.Clear();

            // reset per-group eachgate activation and last active maingate
            groupActivatedEachGates[1].Clear(); groupActivatedEachGates[2].Clear(); groupActivatedEachGates[3].Clear();
            lastActiveMainGate = 0;

            // reset activation order
            activationOrder.Clear();
            activationCounter = 0;

            // reset play published flags
            playPublished[1] = false; playPublished[2] = false; playPublished[3] = false;

            for (int i = 0; i < nodeLights.Count; i++) { int slot = (i % NodesPerGroup) + 1; nodeLights[i].FillColor = Color.Red; nodeLights[i].Invalidate(); batteryLabels[i].Text = $"HeadSet {slot}: -- | Battery: --%"; try { var parent = batteryLabels[i].Parent; var macLbl = parent.Controls.OfType<Label>().Skip(1).FirstOrDefault(); if (macLbl != null) macLbl.Text = "MAC: --"; } catch { } }

            ResetStatusGridColors();

            Logger.Log("Reset all mappings and statuses");
        }
    
        // CirclePanel draws an anti-aliased filled circle based on FillColor
        internal class CirclePanel : Panel
        {
            public Color FillColor { get; set; } = Color.Red;

            public CirclePanel()
            {
                this.SetStyle(ControlStyles.ResizeRedraw | ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint, true);
            }

            protected override void OnPaint(PaintEventArgs e)
            {
                e.Graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
                using (var brush = new SolidBrush(FillColor))
                {
                    e.Graphics.FillEllipse(brush, 0, 0, Width - 1, Height - 1);
                }
                using (var pen = new Pen(Color.FromArgb(100, Color.Black)))
                {
                    e.Graphics.DrawEllipse(pen, 0, 0, Width - 1, Height - 1);
                }
                base.OnPaint(e);
            }
        }

        // SimpleMqttClient and NetworkStreamExtensions are unchanged and exist elsewhere in the project.
    }
}

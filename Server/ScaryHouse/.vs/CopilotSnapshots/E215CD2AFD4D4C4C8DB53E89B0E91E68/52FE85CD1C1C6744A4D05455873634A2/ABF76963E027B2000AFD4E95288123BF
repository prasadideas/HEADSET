using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ScaryHouse
{
    public partial class Form1 : Form
    {
        private const int NodesPerGroup = 5;
        private List<Label> batteryLabels = new List<Label>();
        private List<CirclePanel> nodeLights = new List<CirclePanel>();
        private SimpleMqttClient mqttClient;
        private bool userRequestedDisconnect = false;
        private RoomConfig roomConfig;
        private DataGridView statusGrid;

        // mappings: groupIndex (1..3) -> mac(no colons) -> slot index (0..9)
        private Dictionary<int, Dictionary<string, int>> groupMappings = new Dictionary<int, Dictionary<string, int>>();
        private Dictionary<string, DateTime> lastSeen = new Dictionary<string, DateTime>();
        private Dictionary<string, int> lastBattery = new Dictionary<string, int>();
        private Dictionary<string, bool> isOnline = new Dictionary<string, bool>();
        private TimeSpan offlineTimeout; // will initialize from numericTimeout

        // grid cell last-seen times (key = "r:c")
        private Dictionary<string, DateTime> gridLastSeen = new Dictionary<string, DateTime>();
        // header last-seen times (key = column index)
        private Dictionary<int, DateTime> gridHeaderLastSeen = new Dictionary<int, DateTime>();

        // maingate activation window (not used for 01/02/03 activations)
        private TimeSpan maingateActiveDuration;
        private DateTime maingateActiveUntil = DateTime.MinValue;

        // New: track which maingate was last activated and per-group set of eachgate numbers already handled
        private int lastActiveMainGate = 0; // 0 = none, 1..3 = groups
        private Dictionary<int, HashSet<int>> groupActivatedEachGates = new Dictionary<int, HashSet<int>>();

        // Activation order and lag policy
        private Dictionary<int, int> activationOrder = new Dictionary<int, int>(); // group -> order (1 = first)
        private int activationCounter = 0;
        private const int Lag = 3; // leader must be ahead by at least this many gates

        private int number_of_scaries = 18;
        // private int number_of_headset_per_group = 5;

        // ensure play publish happens only once per group
        private Dictionary<int, bool> playPublished = new Dictionary<int, bool>();
        // per-group per-gate published flags
        private Dictionary<int, HashSet<int>> playPublishedGates = new Dictionary<int, HashSet<int>>();

        public Form1()
        {
            InitializeComponent();

            groupMappings[1] = new Dictionary<string, int>();
            groupMappings[2] = new Dictionary<string, int>();
            groupMappings[3] = new Dictionary<string, int>();

            // initialize per-group activated eachgate sets
            groupActivatedEachGates[1] = new HashSet<int>();
            groupActivatedEachGates[2] = new HashSet<int>();
            groupActivatedEachGates[3] = new HashSet<int>();

            // initialize playPublished flags
            playPublished[1] = false; playPublished[2] = false; playPublished[3] = false;
            playPublishedGates[1] = new HashSet<int>(); playPublishedGates[2] = new HashSet<int>(); playPublishedGates[3] = new HashSet<int>();

            roomConfig = RoomConfig.Load();

            // set number_of_scaries from configuration
            try { number_of_scaries = roomConfig?.NumberOfRooms ?? number_of_scaries; } catch { }

            try { offlineTimeout = TimeSpan.FromSeconds((double)numericTimeout.Value); }
            catch { offlineTimeout = TimeSpan.FromSeconds(20); }

            // theme styling
            this.BackColor = Color.FromArgb(30, 30, 30);
            this.ForeColor = Color.White;

            flowControls.BackColor = Color.FromArgb(45, 45, 48);
            flowControls.ForeColor = Color.White;

            foreach (Control c in flowControls.Controls)
            {
                if (c is Button b)
                {
                    b.FlatStyle = FlatStyle.Flat;
                    b.UseVisualStyleBackColor = false;
                    b.BackColor = Color.FromArgb(63, 63, 70);
                    b.ForeColor = Color.White;
                }
            }
        }

        private async void Form1_Load(object sender, EventArgs e)
        {
               label1.ForeColor = Color.White;
            label1.Text = "v1.2";
            CreateNodeControls(flowGroup1, 1);
            CreateNodeControls(flowGroup2, 2);
            CreateNodeControls(flowGroup3, 3);

            CreateStatusGrid();

            timer1.Start();

            try
            {
                var localIp = GetLocalWifiIpv4();
                if (!string.IsNullOrWhiteSpace(localIp)) textBoxBroker.Text = localIp;
            }
            catch { }

            await SetupMqttClient();
        }

        private string GetLocalWifiIpv4()
        {
            try
            {
                foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    if (ni.NetworkInterfaceType == NetworkInterfaceType.Wireless80211 && ni.OperationalStatus == OperationalStatus.Up)
                    {
                        var uni = ni.GetIPProperties().UnicastAddresses.FirstOrDefault(a => a.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork);
                        if (uni != null) return uni.Address.ToString();
                    }
                }

                foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    if (ni.OperationalStatus != OperationalStatus.Up) continue;
                    var uni = ni.GetIPProperties().UnicastAddresses.FirstOrDefault(a => a.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork);
                    if (uni != null) return uni.Address.ToString();
                }
            }
            catch { }
            return null;
        }

        private void CreateNodeControls(FlowLayoutPanel panel, int groupNumber)
        {
            panel.AutoScroll = true;
            panel.FlowDirection = FlowDirection.TopDown;
            panel.WrapContents = false;
            panel.Padding = new Padding(8);
            panel.BackColor = Color.FromArgb(40, 40, 40);

            var header = new Label()
            {
                Text = $"Group {groupNumber}",
                AutoSize = false,
                Width = panel.ClientSize.Width - 20,
                Height = 34,
                TextAlign = ContentAlignment.MiddleCenter,
                Font = new Font("Segoe UI", 12F, FontStyle.Bold),
                ForeColor = Color.White,
                BackColor = Color.FromArgb(28, 151, 234)
            };
            panel.Controls.Add(header);

            for (int i = 0; i < NodesPerGroup; i++)
            {
                var container = new Panel { Width = panel.ClientSize.Width - 25, Height = 48, BackColor = Color.FromArgb(50, 50, 52), Margin = new Padding(3, 6, 3, 6) };
                var light = new CirclePanel { Width = 28, Height = 28, Left = 8, Top = 10, FillColor = Color.Red };
                var lbl = new Label { AutoSize = false, Width = container.Width - 48, Left = 44, Top = 8, Height = 18, Font = new Font("Segoe UI", 9F), ForeColor = Color.White, Text = $"HeadSet {i + 1}: -- | Battery: --%" };
                var macLabel = new Label { AutoSize = false, Width = container.Width - 48, Left = 44, Top = 26, Height = 14, Font = new Font("Consolas", 8F), ForeColor = Color.LightGray, Text = "MAC: --" };

                container.Controls.Add(light);
                container.Controls.Add(lbl);
                container.Controls.Add(macLabel);
                panel.Controls.Add(container);

                nodeLights.Add(light);
                batteryLabels.Add(lbl);
            }
        }

        private void CreateStatusGrid()
        {
            statusGrid = new DataGridView { Dock = DockStyle.Bottom, Height = 160, ReadOnly = true, AllowUserToAddRows = false, RowHeadersVisible = false };
            statusGrid.EnableHeadersVisualStyles = false;
            statusGrid.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;

            statusGrid.ColumnHeadersDefaultCellStyle.BackColor = Color.FromArgb(45, 45, 48);
            statusGrid.ColumnHeadersDefaultCellStyle.ForeColor = Color.White;
            statusGrid.ColumnHeadersDefaultCellStyle.Font = new Font("Segoe UI", 9F, FontStyle.Bold);
            statusGrid.DefaultCellStyle.SelectionBackColor = Color.DarkOrange;
            statusGrid.DefaultCellStyle.SelectionForeColor = Color.White;

            statusGrid.Columns.Clear();
            statusGrid.Columns.Add("colGroup", "Group");
            statusGrid.Columns[0].Width = 80;
            statusGrid.Columns.Add("colMain", "maingate");
            statusGrid.Columns[1].Width = 70;
            for (int i = 1; i <= number_of_scaries; i++)
            {
                var name = i.ToString("D2");
                statusGrid.Columns.Add("col" + name, name);
                statusGrid.Columns[statusGrid.Columns.Count - 1].Width = 40;
            }

            statusGrid.Rows.Clear();
            for (int r = 1; r <= 3; r++)
            {
                int idx = statusGrid.Rows.Add();
                statusGrid.Rows[idx].Cells[0].Value = "Group " + r;
                statusGrid.Rows[idx].Cells[0].Style.BackColor = Color.FromArgb(45, 45, 48);
                statusGrid.Rows[idx].Cells[0].Style.ForeColor = Color.White;
                statusGrid.Rows[idx].Cells[0].Style.Font = new Font("Segoe UI", 9F, FontStyle.Bold);
            }

            ResetStatusGridColors();

            this.Controls.Add(statusGrid);
            statusGrid.BringToFront();
        }

        private void ResetStatusGridColors()
        {
            if (statusGrid == null) return;
            Invoke(new Action(() =>
            {
                // reset grid last seen map
                gridLastSeen.Clear();
                gridHeaderLastSeen.Clear();

                // set column headers default to black
                statusGrid.ColumnHeadersDefaultCellStyle.BackColor = Color.Black;
                statusGrid.ColumnHeadersDefaultCellStyle.ForeColor = Color.White;

                for (int r = 0; r < statusGrid.Rows.Count; r++)
                {
                    for (int c = 1; c < statusGrid.Columns.Count; c++)
                    {
                        statusGrid.Rows[r].Cells[c].Style.BackColor = Color.Black;
                        statusGrid.Rows[r].Cells[c].Style.ForeColor = Color.White;
                        statusGrid.Rows[r].Cells[c].Value = null;

                        // also ensure header cell for this column is black
                        try { statusGrid.Columns[c].HeaderCell.Style.BackColor = Color.Black; statusGrid.Columns[c].HeaderCell.Style.ForeColor = Color.White; } catch { }
                    }
                }
            }));
        }

        private void UpdateHeaderSeen(int col)
        {
            if (statusGrid == null) return;
            if (col < 1 || col >= statusGrid.Columns.Count) return;

            gridHeaderLastSeen[col] = DateTime.UtcNow;

            Invoke(new Action(() =>
            {
                try
                {
                    statusGrid.Columns[col].HeaderCell.Style.BackColor = Color.LimeGreen;
                    statusGrid.Columns[col].HeaderCell.Style.ForeColor = Color.Black;
                }
                catch { }
            }));
        }

        private async Task SetupMqttClient()
        {
            try
            {
                if (mqttClient != null)
                {
                    try { await mqttClient.DisconnectAsync(); } catch { }
                    mqttClient = null;
                }

                string host = textBoxBroker.Text;

                mqttClient = new SimpleMqttClient();
                mqttClient.MessageReceived += MqttClient_MessageReceived;
                mqttClient.Disconnected += MqttClient_Disconnected;

                await mqttClient.ConnectAsync(host, 1883, "ScaryHouseClient");

                // subscribe to status topics including maindoor and eachgate variations
                await mqttClient.SubscribeAsync(new[] { "status/#" });

                Invoke(new Action(() => buttonConnect.Text = "Connected"));
                Logger.Log($"Connected to MQTT broker {host}");
            }
            catch (Exception ex)
            {
                MessageBox.Show("MQTT connect failed: " + ex.Message);
                Invoke(new Action(() => buttonConnect.Text = "Connect MQTT"));
                Logger.Log($"MQTT connect failed: {ex.Message}");
            }
        }

        private void MqttClient_Disconnected(Exception ex)
        {
            Invoke(new Action(() => buttonConnect.Text = "Connect MQTT"));
            Logger.Log($"Disconnected from MQTT broker: {ex?.Message ?? "unknown"}");

            if (userRequestedDisconnect) return;

            string host = textBoxBroker.Text;
            _ = Task.Run(async () =>
            {
                while (!userRequestedDisconnect)
                {
                    try
                    {
                        var client = new SimpleMqttClient();
                        client.MessageReceived += MqttClient_MessageReceived;
                        client.Disconnected += MqttClient_Disconnected;
                        await client.ConnectAsync(host, 1883, "ScaryHouseClient");
                        await client.SubscribeAsync(new[] { "status/#" });

                        var old = mqttClient; mqttClient = client; try { old?.Dispose(); } catch { }
                        Invoke(new Action(() => buttonConnect.Text = "Connected"));
                        Logger.Log($"Reconnected to MQTT broker {host}");
                        break;
                    }
                    catch { await Task.Delay(5000); }
                }
            });
        }

        // helper: next expected eachgate number for a group (1..number_of_scaries), or -1 if none
        private int GetNextExpectedForGroup(int group)
        {
            if (!groupActivatedEachGates.TryGetValue(group, out var set)) return 1;
            for (int i = 1; i <= number_of_scaries; i++) if (!set.Contains(i)) return i;
            return -1;
        }

        private void HandleMainDoorMessage(string topic, string payload)
        {
            // payload expected 2-digit switch number "00","01","02","03"
            if (string.IsNullOrWhiteSpace(payload) || payload.Length < 2) return;
            var val = payload.Trim();
            if (val == "00")
            {
                // heartbeat: only mark maingate header as seen (data cells handled elsewhere)
                UpdateHeaderSeen(1);
                return;
            }
            if (!int.TryParse(val, out int switchNum)) return;
            if (switchNum < 1 || switchNum > 3) return;

            int row = switchNum - 1; // map 1->row0,2->row1,3->row2
            int col = 1; // maingate column index

            // mark seen (temporary until timeout)
            UpdateGridCellSeen(row, col);

            // update last active maingate so subsequent eachgate messages are applied to this group
            // activation commands 01/02/03 are one-time and are not time-limited
            lastActiveMainGate = switchNum;
            Logger.Log($"Maingate {switchNum} activated");

            // record activation order if first time
            if (!activationOrder.ContainsKey(switchNum))
            {
                activationCounter++;
                activationOrder[switchNum] = activationCounter;
            }

            Logger.Log($"MainDoor switch {val} pressed -> Group {row + 1} maingate");
        }

        private void HandleEachGateMessage(string topic, string payload)
        {
            // try to extract gate number from topic suffix after 'eachgate'
            int idx = topic.ToLower().IndexOf("eachgate");
            int gateNum = -1;
            if (idx >= 0)
            {
                var suffix = topic.Substring(idx + "eachgate".Length);
                // try parse digits from suffix
                var digits = new string(suffix.Where(char.IsDigit).ToArray());
                if (!string.IsNullOrWhiteSpace(digits)) int.TryParse(digits, out gateNum);
            }

            // if we couldn't parse gate from topic, try payload
            if (gateNum == -1)
            {
                if (int.TryParse(payload.Trim(), out int pval)) gateNum = pval;
            }

            if (gateNum < 1 || gateNum > number_of_scaries)
            {
                // fallback: if payload is '00' treat as heartbeat for all eachgate headers
                if (payload.Trim() == "00")
                {
                    for (int g = 1; g <= number_of_scaries; g++)
                    {
                        int headerCol = 1 + g;
                        UpdateHeaderSeen(headerCol);
                    }
                }
                return;
            }

            // For heartbeat (payload '00') mark the corresponding column for all groups as seen
            if (payload.Trim() == "00")
            {
                int col = 1 + gateNum;
                // heartbeat: only update header for this eachgate column
                UpdateHeaderSeen(col);
                return;
            }

            // For non-heartbeat eachgate messages: only accept if lastActiveMainGate exists
            // Determine which group should receive this eachgate event.
            // Priority: if lastActiveMainGate expects this gateNum -> use it.
            // Otherwise, find any group whose next expected equals gateNum.
            int targetGroup = -1;

            int activeNext = GetNextExpectedForGroup(lastActiveMainGate);
            if (activeNext == gateNum) targetGroup = lastActiveMainGate;

            if (targetGroup == -1)
            {
                for (int g = 1; g <= 3; g++)
                {
                    // only consider groups that have been activated via maingate (01/02/03)
                    if (!activationOrder.ContainsKey(g)) continue;
                    int next = GetNextExpectedForGroup(g);
                    if (next == gateNum) { targetGroup = g; break; }
                }
            }

            if (targetGroup == -1)
            {
                Logger.Log($"EachGate event {gateNum} ignored - no group expects gate {gateNum}");
                return;
            }

             var set = groupActivatedEachGates[targetGroup];
             if (set.Contains(gateNum))
             {
                 Logger.Log($"EachGate {gateNum} for Group {targetGroup} ignored - already activated");
                 return;
             }

             // Enforce fixed lag policy: check previous group progress if activationOrder exists
             int prevGroup = -1;
             if (activationOrder.TryGetValue(targetGroup, out int targetOrder) && targetOrder > 1)
             {
                 int desiredOrder = targetOrder - 1;
                 var kv = activationOrder.FirstOrDefault(x => x.Value == desiredOrder);
                 if (!kv.Equals(default(KeyValuePair<int,int>))) prevGroup = kv.Key;
             }
             if (prevGroup != -1 && prevGroup != targetGroup)
             {
                 int prevNext = GetNextExpectedForGroup(prevGroup);
                 int followerNext = GetNextExpectedForGroup(targetGroup);
                // If previous group has completed all gates (prevNext == -1) then do not enforce the lag
                 if (prevNext != -1)
                 {
                     int prevProgress = (prevNext == -1) ? number_of_scaries : (prevNext - 1);
                     int followerProgress = (followerNext == -1) ? number_of_scaries : (followerNext - 1);
                     if (prevProgress - followerProgress < Lag)
                     {
                         Logger.Log($"EachGate {gateNum} for Group {targetGroup} denied - previous Group {prevGroup} progress {prevProgress} too close to follower {followerProgress}");
                         // try to reassign to earlier groups (as before)
                         bool reassigned = false;
                         var ordered = activationOrder.OrderByDescending(kv => kv.Value).Select(kv => kv.Key).ToList();
                         foreach (var g in ordered)
                         {
                             if (g == targetGroup) continue;
                             int nextg = GetNextExpectedForGroup(g);
                             if (nextg != gateNum) continue;
                             int pg = -1;
                             if (activationOrder.TryGetValue(g, out int ordg) && ordg > 1)
                             {
                                 var kvp = activationOrder.FirstOrDefault(x => x.Value == ordg - 1);
                                 if (!kvp.Equals(default(KeyValuePair<int,int>))) pg = kvp.Key;
                             }
                             if (pg != -1)
                             {
                                 int pgNext = GetNextExpectedForGroup(pg);
                                 int gNext = GetNextExpectedForGroup(g);
                                 int prevgProgress = (pgNext == -1) ? number_of_scaries : (pgNext - 1);
                                 int gProgress = (gNext == -1) ? number_of_scaries : (gNext - 1);
                                 // if previous-of-candidate already completed, don't block the candidate
                                 if (pgNext != -1 && prevgProgress - gProgress < Lag) continue;
                             }

                            targetGroup = g; set = groupActivatedEachGates[targetGroup];
                            reassigned = true; break;
                         }

                         if (!reassigned) return;
                     }
                 }
             }

            // mark persistent for target group only
            int rowIdx = targetGroup - 1;
            int colIdx = 1 + gateNum; // columns: 0=Group,1=maingate,2=01,...
            MarkGridCellPersistent(rowIdx, colIdx);

            // remember that this eachgate has been activated for this group
            set.Add(gateNum);

            // schedule one-time delayed publish for this group's gate if not already done
            if (!playPublishedGates.TryGetValue(targetGroup, out var publishedSet))
            {
                publishedSet = new HashSet<int>(); playPublishedGates[targetGroup] = publishedSet;
            }

            if (!publishedSet.Contains(gateNum))
            {
                publishedSet.Add(gateNum);
                int delaySeconds = 20; // default
                try { if (roomConfig?.RoomSeconds != null && roomConfig.RoomSeconds.Count >= gateNum) delaySeconds = roomConfig.RoomSeconds[gateNum - 1]; } catch { }
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await Task.Delay(delaySeconds * 1000);
                        string roomNo = gateNum.ToString("D2");
                        string pubPayload = $"play,{roomNo}";
                        string pubTopic = $"music/group{targetGroup}";
                        await PublishIfConnected(pubTopic, pubPayload, false);
                        Logger.Log($"Published scheduled play for Group {targetGroup} room {roomNo}");
                    }
                    catch (Exception ex)
                    {
                        Logger.Log($"Scheduled publish failed: {ex.Message}");
                    }
                });
            }

            Logger.Log($"EachGate event gate {gateNum} applied to Group {targetGroup}");
        }

        private void UpdateGridCellSeen(int row, int col)
        {
            if (statusGrid == null) return;
            if (row < 0 || row >= statusGrid.Rows.Count) return;
            if (col < 1 || col >= statusGrid.Columns.Count) return;

            string key = row + ":" + col;
            gridLastSeen[key] = DateTime.UtcNow;

            Invoke(new Action(() =>
            {
                var cell = statusGrid.Rows[row].Cells[col];
                cell.Style.BackColor = Color.LimeGreen;
                cell.Style.ForeColor = Color.Black;
                cell.Value = null;
            }));
        }

        private void MarkGridCellPersistent(int row, int col)
        {
            if (statusGrid == null) return;
            if (row < 0 || row >= statusGrid.Rows.Count) return;
            if (col < 1 || col >= statusGrid.Columns.Count) return;

            Invoke(new Action(() =>
            {
                var cell = statusGrid.Rows[row].Cells[col];
                cell.Style.BackColor = Color.LimeGreen;
                cell.Style.ForeColor = Color.Black;
                cell.Value = null; // keep no text
            }));
        }

        private void numericTimeout_ValueChanged(object sender, EventArgs e)
        {
            try { offlineTimeout = TimeSpan.FromSeconds((double)numericTimeout.Value); } catch { }
            // maingate activation commands (01/02/03) are one-time and not time-limited
        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            var now = DateTime.UtcNow;

            // handle headset offline / node lights as before
            foreach (var kv in lastSeen.ToList())
            {
                if (now - kv.Value > offlineTimeout)
                {
                    var mac = kv.Key;
                    int battery = lastBattery.ContainsKey(mac) ? lastBattery[mac] : 0;
                    for (int g = 1; g <= 3; g++)
                    {
                        if (groupMappings[g].TryGetValue(mac, out int slot))
                        {
                            int globalIndex = (g - 1) * NodesPerGroup + slot;
                            if (globalIndex >= 0 && globalIndex < nodeLights.Count)
                            {
                                nodeLights[globalIndex].FillColor = Color.Red;
                                batteryLabels[globalIndex].Text = $"HeadSet {slot + 1}: Battery: {battery}% (offline)";
                                nodeLights[globalIndex].Invalidate();

                                if (isOnline.TryGetValue(mac, out bool wasOnline) && wasOnline)
                                {
                                    isOnline[mac] = false;
                                    Logger.Log($"Device {mac} Group {g} HeadSet {slot + 1} OFFLINE battery {battery}%");
                                }
                            }
                        }
                    }
                }
            }

            // handle grid cell timeouts -> set to black when stale
            if (statusGrid != null)
            {
                for (int r = 0; r < statusGrid.Rows.Count; r++)
                {
                    for (int c = 1; c < statusGrid.Columns.Count; c++)
                    {
                        // do not apply timer-based expiry to maingate column (index 1) — only headers should time out
                        if (c == 1) continue;

                        string key = r + ":" + c;
                        if (gridLastSeen.TryGetValue(key, out DateTime seen))
                        {
                            if (now - seen > offlineTimeout)
                            {
                                // stale -> mark black and remove tracking
                                gridLastSeen.Remove(key);
                                try
                                {
                                    Invoke(new Action(() =>
                                    {
                                        var cell = statusGrid.Rows[r].Cells[c];
                                        cell.Style.BackColor = Color.Black;
                                        cell.Style.ForeColor = Color.White;
                                        cell.Value = null;
                                    }));
                                }
                                catch { }
                            }
                        }
                        else
                        {
                            // never seen -> keep black (already default)
                        }
                    }
                }

                // handle header timeouts
                if (gridHeaderLastSeen.Count > 0)
                {
                    var toRemove = new List<int>();
                    foreach (var kv in gridHeaderLastSeen)
                    {
                        if (now - kv.Value > offlineTimeout)
                        {
                            int col = kv.Key; toRemove.Add(col);
                            try
                            {
                                Invoke(new Action(() =>
                                {
                                    if (col >= 1 && col < statusGrid.Columns.Count)
                                    {
                                        statusGrid.Columns[col].HeaderCell.Style.BackColor = Color.Black;
                                        statusGrid.Columns[col].HeaderCell.Style.ForeColor = Color.White;
                                    }
                                }));
                            }
                            catch { }
                        }
                    }
                    foreach (var c in toRemove) gridHeaderLastSeen.Remove(c);
                }
            }
        }

        private void MqttClient_MessageReceived(string topic, byte[] payload)
        {
            try
            {
                string payloadStr = Encoding.UTF8.GetString(payload);

                // table topics
                if (topic.IndexOf("maindoor", StringComparison.InvariantCultureIgnoreCase) >= 0) { HandleMainDoorMessage(topic, payloadStr); return; }
                if (topic.IndexOf("eachgate", StringComparison.InvariantCultureIgnoreCase) >= 0) { HandleEachGateMessage(topic, payloadStr); return; }

                // expected format: mac,battery
                var parts = payloadStr.Split(new[] { ',', ';', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length < 2) return;
                string mac = parts[0].Trim(); if (mac.Contains(":")) mac = mac.Replace(":", ""); if (mac.Length == 0) return;
                if (!int.TryParse(parts[1], out int battery)) battery = 0;

                int group = 0;
                if (topic.EndsWith("group1", StringComparison.InvariantCultureIgnoreCase)) group = 1;
                else if (topic.EndsWith("group2", StringComparison.InvariantCultureIgnoreCase)) group = 2;
                else if (topic.EndsWith("group3", StringComparison.InvariantCultureIgnoreCase)) group = 3;
                if (group == 0) return;

                // Reject if same MAC in other group
                for (int g = 1; g <= 3; g++) if (g != group && groupMappings[g].ContainsKey(mac)) { Logger.Log($"Rejected status from {mac} for group {group} - already assigned to group {g}"); return; }

                // assign slot if new
                if (!groupMappings[group].TryGetValue(mac, out int slotIndex))
                {
                    var used = new HashSet<int>(groupMappings[group].Values);
                    int found = -1;
                    for (int i = 0; i < NodesPerGroup; i++) if (!used.Contains(i)) { found = i; break; }
                    if (found == -1) return;
                    slotIndex = found; groupMappings[group][mac] = slotIndex;
                }

                // update last seen and battery
                lastSeen[mac] = DateTime.UtcNow; lastBattery[mac] = battery;

                int globalIndex = (group - 1) * NodesPerGroup + slotIndex;
                if (globalIndex >= 0 && globalIndex < nodeLights.Count)
                {
                    bool wasOnline = false; isOnline.TryGetValue(mac, out wasOnline);
                    Invoke(new Action(() =>
                    {
                        nodeLights[globalIndex].FillColor = Color.LimeGreen; nodeLights[globalIndex].Invalidate();
                        batteryLabels[globalIndex].Text = $"HeadSet {slotIndex + 1}: Battery: {battery}%";
                        try { var parent = batteryLabels[globalIndex].Parent; var macLbl = parent.Controls.OfType<Label>().Skip(1).FirstOrDefault(); if (macLbl != null) macLbl.Text = "MAC: " + mac; } catch { }
                    }));

                    if (!wasOnline) { isOnline[mac] = true; Logger.Log($"Device {mac} Group {group} HeadSet {slotIndex + 1} ONLINE battery {battery}%"); }
                }
            }
            catch { }
        }

        private async void buttonConnect_Click(object sender, EventArgs e)
        {
            if (mqttClient != null && mqttClient.IsConnected)
            {
                userRequestedDisconnect = true; await mqttClient.DisconnectAsync(); userRequestedDisconnect = false; buttonConnect.Text = "Connect MQTT"; return;
            }
            await SetupMqttClient();
        }

        private void RecreateStatusGrid()
        {
            try
            {
                if (statusGrid != null)
                {
                    this.Controls.Remove(statusGrid);
                    try { statusGrid.Dispose(); } catch { }
                    statusGrid = null;
                }
            }
            catch { }
            CreateStatusGrid();
        }

        private void buttonUpdateConfig_Click(object sender, EventArgs e)
        {
            using (var dlg = new RoomSettingsForm(roomConfig))
            {
                if (dlg.ShowDialog(this) == DialogResult.OK)
                {
                    // reload config and apply number_of_scaries
                    roomConfig = RoomConfig.Load();
                    try { number_of_scaries = roomConfig?.NumberOfRooms ?? number_of_scaries; } catch { }

                    RecreateStatusGrid();

                    Logger.Log("Room timers updated"); MessageBox.Show("Room timers saved");
                }
            }
        }

        // Add missing pub handlers (wired in designer)
        private async void buttonPub1_Click(object sender, EventArgs e) => await PublishIfConnected("music/group1", "play");
        private async void buttonPub2_Click(object sender, EventArgs e) => await PublishIfConnected("music/group2", "play");
        private async void buttonPub3_Click(object sender, EventArgs e) => await PublishIfConnected("music/group3", "play");

        private async Task PublishIfConnected(string topic, string payload, bool showMessage = true)
        {
            if (mqttClient == null || !mqttClient.IsConnected) { if (showMessage) MessageBox.Show("Not connected to MQTT broker"); return; }
            try { await mqttClient.PublishAsync(topic, Encoding.UTF8.GetBytes(payload)); if (showMessage) MessageBox.Show($"Published to {topic}"); }
            catch (Exception ex) { if (showMessage) MessageBox.Show("Publish failed: " + ex.Message); }
        }

        private void buttonReset_Click(object sender, EventArgs e)
        {
            groupMappings[1].Clear(); groupMappings[2].Clear(); groupMappings[3].Clear(); lastSeen.Clear(); lastBattery.Clear(); isOnline.Clear();

            // reset per-group eachgate activation and last active maingate
            groupActivatedEachGates[1].Clear(); groupActivatedEachGates[2].Clear(); groupActivatedEachGates[3].Clear();
            lastActiveMainGate = 0;

            // reset activation order
            activationOrder.Clear();
            activationCounter = 0;

            // reset play published flags
            playPublished[1] = false; playPublished[2] = false; playPublished[3] = false;
            playPublishedGates[1].Clear(); playPublishedGates[2].Clear(); playPublishedGates[3].Clear();

            for (int i = 0; i < nodeLights.Count; i++) { int slot = (i % NodesPerGroup) + 1; nodeLights[i].FillColor = Color.Red; nodeLights[i].Invalidate(); batteryLabels[i].Text = $"HeadSet {slot}: -- | Battery: --%"; try { var parent = batteryLabels[i].Parent; var macLbl = parent.Controls.OfType<Label>().Skip(1).FirstOrDefault(); if (macLbl != null) macLbl.Text = "MAC: --"; } catch { } }

            ResetStatusGridColors();

            Logger.Log("Reset all mappings and statuses");
        }
    
        // CirclePanel draws an anti-aliased filled circle based on FillColor
        internal class CirclePanel : Panel
        {
            public Color FillColor { get; set; } = Color.Red;

            public CirclePanel()
            {
                this.SetStyle(ControlStyles.ResizeRedraw | ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint, true);
            }

            protected override void OnPaint(PaintEventArgs e)
            {
                e.Graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
                using (var brush = new SolidBrush(FillColor))
                {
                    e.Graphics.FillEllipse(brush, 0, 0, Width - 1, Height - 1);
                }
                using (var pen = new Pen(Color.FromArgb(100, Color.Black)))
                {
                    e.Graphics.DrawEllipse(pen, 0, 0, Width - 1, Height - 1);
                }
                base.OnPaint(e);
            }
        }

        // SimpleMqttClient and NetworkStreamExtensions are unchanged and exist elsewhere in the project.
    }
}

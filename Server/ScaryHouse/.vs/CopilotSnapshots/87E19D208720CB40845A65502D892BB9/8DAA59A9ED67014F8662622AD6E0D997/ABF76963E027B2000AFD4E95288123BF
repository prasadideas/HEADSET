using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ScaryHouse
{
    public partial class Form1 : Form
    {
        private const int NodesPerGroup = 10;
        private List<Label> batteryLabels = new List<Label>();
        private List<CirclePanel> nodeLights = new List<CirclePanel>();
        private SimpleMqttClient mqttClient;

        // mappings: groupIndex (1..3) -> mac(no colons) -> slot index (0..9)
        private Dictionary<int, Dictionary<string, int>> groupMappings = new Dictionary<int, Dictionary<string, int>>();
        private Dictionary<string, DateTime> lastSeen = new Dictionary<string, DateTime>();
        private Dictionary<string, int> lastBattery = new Dictionary<string, int>();
        private TimeSpan offlineTimeout = TimeSpan.FromSeconds(15);

        public Form1()
        {
            InitializeComponent();
            groupMappings[1] = new Dictionary<string, int>();
            groupMappings[2] = new Dictionary<string, int>();
            groupMappings[3] = new Dictionary<string, int>();

            // Style form
            this.BackColor = Color.FromArgb(30, 30, 30);
            this.ForeColor = Color.White;
            this.Font = new Font("Segoe UI", 9F, FontStyle.Regular);

            // Style control panel
            flowControls.BackColor = Color.FromArgb(45, 45, 48);
            flowControls.ForeColor = Color.White;

            // Buttons style
            foreach (Control c in flowControls.Controls)
            {
                if (c is Button b)
                {
                    b.FlatStyle = FlatStyle.Flat;
                    b.BackColor = Color.FromArgb(63, 63, 70);
                    b.ForeColor = Color.White;
                }
            }
        }

        private async void Form1_Load(object sender, EventArgs e)
        {
            // create node controls with headers
            CreateNodeControls(flowGroup1, 1);
            CreateNodeControls(flowGroup2, 2);
            CreateNodeControls(flowGroup3, 3);

            timer1.Start();

            // try auto connect
            await SetupMqttClient();
        }

        private void CreateNodeControls(FlowLayoutPanel panel, int groupNumber)
        {
            panel.AutoScroll = true;
            panel.FlowDirection = FlowDirection.TopDown;
            panel.WrapContents = false;
            panel.Padding = new Padding(8);
            panel.BackColor = Color.FromArgb(40, 40, 40);

            // header
            var header = new Label()
            {
                Text = $"Group {groupNumber}",
                AutoSize = false,
                Width = panel.ClientSize.Width - 20,
                Height = 34,
                TextAlign = ContentAlignment.MiddleCenter,
                Font = new Font("Segoe UI", 12F, FontStyle.Bold),
                ForeColor = Color.White,
                BackColor = Color.FromArgb(28, 151, 234)
            };
            panel.Controls.Add(header);

            for (int i = 0; i < NodesPerGroup; i++)
            {
                var container = new Panel();
                container.Width = panel.ClientSize.Width - 25;
                container.Height = 48;
                container.BackColor = Color.FromArgb(50, 50, 52);
                container.Margin = new Padding(3, 6, 3, 6);

                var light = new CirclePanel();
                light.Width = 28;
                light.Height = 28;
                light.Left = 8;
                light.Top = 10;
                light.FillColor = Color.Red;

                var lbl = new Label();
                lbl.AutoSize = false;
                lbl.Width = container.Width - 48;
                lbl.Left = 44;
                lbl.Top = 8;
                lbl.Height = 18;
                lbl.Font = new Font("Segoe UI", 9F, FontStyle.Regular);
                lbl.ForeColor = Color.White;
                lbl.Text = $"Slot {i + 1}: -- | Battery: --%";

                var macLabel = new Label();
                macLabel.AutoSize = false;
                macLabel.Width = container.Width - 48;
                macLabel.Left = 44;
                macLabel.Top = 26;
                macLabel.Height = 14;
                macLabel.Font = new Font("Consolas", 8F, FontStyle.Regular);
                macLabel.ForeColor = Color.LightGray;
                macLabel.Text = "MAC: --";

                container.Controls.Add(light);
                container.Controls.Add(lbl);
                container.Controls.Add(macLabel);
                panel.Controls.Add(container);

                nodeLights.Add(light);
                batteryLabels.Add(lbl);
            }
        }

        private Random rnd = new Random();

        private void timer1_Tick(object sender, EventArgs e)
        {
            // mark offline if not seen recently
            var now = DateTime.UtcNow;
            foreach (var kv in lastSeen.ToList())
            {
                if (now - kv.Value > offlineTimeout)
                {
                    // set corresponding UI to offline
                    var mac = kv.Key;
                    int battery = lastBattery.ContainsKey(mac) ? lastBattery[mac] : 0;
                    // find mapping
                    for (int g = 1; g <= 3; g++)
                    {
                        if (groupMappings[g].TryGetValue(mac, out int slot))
                        {
                            int globalIndex = (g - 1) * NodesPerGroup + slot;
                            if (globalIndex >= 0 && globalIndex < nodeLights.Count)
                            {
                                nodeLights[globalIndex].FillColor = Color.Red;
                                batteryLabels[globalIndex].Text = $"Slot {slot + 1}: Battery: {battery}% (offline)";
                                nodeLights[globalIndex].Invalidate();
                            }
                        }
                    }
                }
            }

            // when no real MQTT messages, still show some simulated activity for unassigned nodes (optional)
            // Previously we simulated all nodes; now we only keep offline checks. You can re-enable random simulation if desired.
        }

        private async Task SetupMqttClient()
        {
            try
            {
                if (mqttClient != null)
                {
                    try { await mqttClient.DisconnectAsync(); } catch { }
                    mqttClient = null;
                }

                mqttClient = new SimpleMqttClient();
                mqttClient.MessageReceived += MqttClient_MessageReceived;
                string host = textBoxBroker.Text;
                await mqttClient.ConnectAsync(host, 1883, "ScaryHouseClient");

                // subscribe to status topics
                await mqttClient.SubscribeAsync(new[] { "status/group1", "status/group2", "status/group3" });

                Invoke(new Action(() => buttonConnect.Text = "Connected"));
            }
            catch (Exception ex)
            {
                MessageBox.Show("MQTT connect failed: " + ex.Message);
            }
        }

        private void MqttClient_MessageReceived(string topic, byte[] payload)
        {
            try
            {
                string payloadStr = Encoding.UTF8.GetString(payload);
                // expected format: mac,battery  e.g. AABBCCDDEEFF,85
                var parts = payloadStr.Split(new[] { ',', ';', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length < 2) return;
                string mac = parts[0].Trim();
                if (mac.Contains(":")) mac = mac.Replace(":", "");
                if (mac.Length == 0) return;
                if (!int.TryParse(parts[1], out int battery)) battery = 0;

                int group = 0;
                if (topic.EndsWith("group1", StringComparison.InvariantCultureIgnoreCase)) group = 1;
                else if (topic.EndsWith("group2", StringComparison.InvariantCultureIgnoreCase)) group = 2;
                else if (topic.EndsWith("group3", StringComparison.InvariantCultureIgnoreCase)) group = 3;
                if (group == 0) return;

                // assign slot if new
                if (!groupMappings[group].TryGetValue(mac, out int slotIndex))
                {
                    // find first free slot (0..9) not used by another mac
                    var used = new HashSet<int>(groupMappings[group].Values);
                    int found = -1;
                    for (int i = 0; i < NodesPerGroup; i++)
                    {
                        if (!used.Contains(i)) { found = i; break; }
                    }
                    if (found == -1)
                    {
                        // no free slot, ignore
                        return;
                    }
                    slotIndex = found;
                    groupMappings[group][mac] = slotIndex;
                }

                // update last seen and battery
                lastSeen[mac] = DateTime.UtcNow;
                lastBattery[mac] = battery;

                int globalIndex = (group - 1) * NodesPerGroup + slotIndex;
                if (globalIndex >= 0 && globalIndex < nodeLights.Count)
                {
                    // update UI on UI thread
                    Invoke(new Action(() =>
                    {
                        nodeLights[globalIndex].FillColor = Color.LimeGreen;
                        nodeLights[globalIndex].Invalidate();
                        batteryLabels[globalIndex].Text = $"Slot {slotIndex + 1}: Battery: {battery}%";

                        // attempt to find and update MAC label beneath (third control)
                        try
                        {
                            var parent = batteryLabels[globalIndex].Parent;
                            var macLbl = parent.Controls.OfType<Label>().Skip(1).FirstOrDefault();
                            if (macLbl != null) macLbl.Text = "MAC: " + mac;
                        }
                        catch { }
                    }));
                }
            }
            catch { }
        }

        private async void buttonConnect_Click(object sender, EventArgs e)
        {
            if (mqttClient != null && mqttClient.IsConnected)
            {
                await mqttClient.DisconnectAsync();
                buttonConnect.Text = "Connect MQTT";
                return;
            }

            await SetupMqttClient();
        }

        private void buttonUpdateConfig_Click(object sender, EventArgs e)
        {
            // placeholder for configuration update
            MessageBox.Show("Configuration updated (placeholder)");
        }

        private async void buttonPub1_Click(object sender, EventArgs e)
        {
            await PublishIfConnected("music/group1", "play");
        }

        private async void buttonPub2_Click(object sender, EventArgs e)
        {
            await PublishIfConnected("music/group2", "play");
        }

        private async void buttonPub3_Click(object sender, EventArgs e)
        {
            await PublishIfConnected("music/group3", "play");
        }

        private async Task PublishIfConnected(string topic, string payload)
        {
            if (mqttClient == null || !mqttClient.IsConnected)
            {
                MessageBox.Show("Not connected to MQTT broker");
                return;
            }

            try
            {
                await mqttClient.PublishAsync(topic, Encoding.UTF8.GetBytes(payload));
                MessageBox.Show($"Published to {topic}");
            }
            catch (Exception ex)
            {
                MessageBox.Show("Publish failed: " + ex.Message);
            }
        }
    }

    // CirclePanel draws an anti-aliased filled circle based on FillColor
    internal class CirclePanel : Panel
    {
        public Color FillColor { get; set; } = Color.Red;

        public CirclePanel()
        {
            this.SetStyle(ControlStyles.ResizeRedraw | ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint, true);
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
            using (var brush = new SolidBrush(FillColor))
            {
                e.Graphics.FillEllipse(brush, 0, 0, Width - 1, Height - 1);
            }
            using (var pen = new Pen(Color.FromArgb(100, Color.Black)))
            {
                e.Graphics.DrawEllipse(pen, 0, 0, Width - 1, Height - 1);
            }
            base.OnPaint(e);
        }
    }

    // SimpleMqttClient unchanged from previous implementation (omitted for brevity in this view)
    // ... existing SimpleMqttClient and NetworkStreamExtensions code remains unchanged ...
}

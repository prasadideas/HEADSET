using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ScaryHouse
{
    public partial class Form1 : Form
    {
        private const int NodesPerGroup = 10;
        private List<Label> batteryLabels = new List<Label>();
        private List<CirclePanel> nodeLights = new List<CirclePanel>();
        private SimpleMqttClient mqttClient;
        private bool userRequestedDisconnect = false;
        private RoomConfig roomConfig;
        private DataGridView statusGrid;

        private Dictionary<int, Dictionary<string, int>> groupMappings = new Dictionary<int, Dictionary<string, int>>();
        private Dictionary<string, DateTime> lastSeen = new Dictionary<string, DateTime>();
        private Dictionary<string, int> lastBattery = new Dictionary<string, int>();
        private Dictionary<string, bool> isOnline = new Dictionary<string, bool>();
        private TimeSpan offlineTimeout;

        public Form1()
        {
            InitializeComponent();

            groupMappings[1] = new Dictionary<string, int>();
            groupMappings[2] = new Dictionary<string, int>();
            groupMappings[3] = new Dictionary<string, int>();

            roomConfig = RoomConfig.Load();

            try { offlineTimeout = TimeSpan.FromSeconds((double)numericTimeout.Value); }
            catch { offlineTimeout = TimeSpan.FromSeconds(20); }

            // basic styling
            this.BackColor = Color.FromArgb(30, 30, 30);
            this.ForeColor = Color.White;
            this.Font = new Font("Segoe UI", 9F);

            // Style control panel
            flowControls.BackColor = Color.FromArgb(45, 45, 48);
            flowControls.ForeColor = Color.White;

            // Buttons style: ensure UseVisualStyleBackColor = false so BackColor is applied
            foreach (Control c in flowControls.Controls)
            {
                if (c is Button b)
                {
                    b.FlatStyle = FlatStyle.Flat;
                    b.UseVisualStyleBackColor = false; // allow custom backcolor
                    b.BackColor = Color.FromArgb(63, 63, 70);
                    b.ForeColor = Color.White;
                }
            }
        }

        private async void Form1_Load(object sender, EventArgs e)
        {
            CreateNodeControls(flowGroup1, 1);
            CreateNodeControls(flowGroup2, 2);
            CreateNodeControls(flowGroup3, 3);

            CreateStatusGrid();

            timer1.Start();

            // try auto-fill broker from wifi
            try
            {
                var localIp = GetLocalWifiIpv4();
                if (!string.IsNullOrWhiteSpace(localIp)) textBoxBroker.Text = localIp;
            }
            catch { }

            await SetupMqttClient();
        }

        private string GetLocalWifiIpv4()
        {
            try
            {
                foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    if (ni.NetworkInterfaceType == NetworkInterfaceType.Wireless80211 && ni.OperationalStatus == OperationalStatus.Up)
                    {
                        var uni = ni.GetIPProperties().UnicastAddresses.FirstOrDefault(a => a.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork);
                        if (uni != null) return uni.Address.ToString();
                    }
                }

                foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    if (ni.OperationalStatus != OperationalStatus.Up) continue;
                    var uni = ni.GetIPProperties().UnicastAddresses.FirstOrDefault(a => a.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork);
                    if (uni != null) return uni.Address.ToString();
                }
            }
            catch { }
            return null;
        }

        private void CreateNodeControls(FlowLayoutPanel panel, int groupNumber)
        {
            panel.AutoScroll = true;
            panel.FlowDirection = FlowDirection.TopDown;
            panel.WrapContents = false;
            panel.Padding = new Padding(8);
            panel.BackColor = Color.FromArgb(40, 40, 40);

            var header = new Label
            {
                Text = $"Group {groupNumber}",
                AutoSize = false,
                Width = panel.ClientSize.Width - 20,
                Height = 34,
                TextAlign = ContentAlignment.MiddleCenter,
                Font = new Font("Segoe UI", 12F, FontStyle.Bold),
                ForeColor = Color.White,
                BackColor = Color.FromArgb(28, 151, 234)
            };
            panel.Controls.Add(header);

            for (int i = 0; i < NodesPerGroup; i++)
            {
                var container = new Panel { Width = panel.ClientSize.Width - 25, Height = 48, BackColor = Color.FromArgb(50, 50, 52), Margin = new Padding(3, 6, 3, 6) };

                var light = new CirclePanel { Width = 28, Height = 28, Left = 8, Top = 10, FillColor = Color.Red };
                var lbl = new Label { AutoSize = false, Width = container.Width - 48, Left = 44, Top = 8, Height = 18, Font = new Font("Segoe UI", 9F), ForeColor = Color.White, Text = $"HeadSet {i + 1}: -- | Battery: --%" };
                var macLabel = new Label { AutoSize = false, Width = container.Width - 48, Left = 44, Top = 26, Height = 14, Font = new Font("Consolas", 8F), ForeColor = Color.LightGray, Text = "MAC: --" };

                container.Controls.Add(light);
                container.Controls.Add(lbl);
                container.Controls.Add(macLabel);
                panel.Controls.Add(container);

                nodeLights.Add(light);
                batteryLabels.Add(lbl);
            }
        }

        private void CreateStatusGrid()
        {
            statusGrid = new DataGridView { Dock = DockStyle.Bottom, Height = 160, ReadOnly = true, AllowUserToAddRows = false, RowHeadersVisible = false };
            statusGrid.EnableHeadersVisualStyles = false; // allow header coloring
            statusGrid.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;

            // header style
            statusGrid.ColumnHeadersDefaultCellStyle.BackColor = Color.FromArgb(45,45,48);
            statusGrid.ColumnHeadersDefaultCellStyle.ForeColor = Color.White;
            statusGrid.ColumnHeadersDefaultCellStyle.Font = new Font("Segoe UI", 9F, FontStyle.Bold);
            statusGrid.DefaultCellStyle.SelectionBackColor = Color.DarkOrange;
            statusGrid.DefaultCellStyle.SelectionForeColor = Color.White;

            statusGrid.Columns.Clear();
            statusGrid.Columns.Add("colGroup", "Group");
            statusGrid.Columns[0].Width = 80;
            statusGrid.Columns.Add("colMain", "maingate");
            statusGrid.Columns[1].Width = 70;
            for (int i = 1; i <= 15; i++)
            {
                var name = i.ToString("D2");
                statusGrid.Columns.Add("col" + name, name);
                statusGrid.Columns[statusGrid.Columns.Count - 1].Width = 40;
            }

            statusGrid.Rows.Clear();
            for (int r = 1; r <= 3; r++)
            {
                int idx = statusGrid.Rows.Add();
                statusGrid.Rows[idx].Cells[0].Value = "Group " + r;
            }

            ResetStatusGridColors();

            this.Controls.Add(statusGrid);
            statusGrid.BringToFront();
        }

        private void ResetStatusGridColors()
        {
            if (statusGrid == null) return;
            Invoke(new Action(() =>
            {
                for (int r = 0; r < statusGrid.Rows.Count; r++)
                {
                    for (int c = 1; c < statusGrid.Columns.Count; c++)
                    {
                        statusGrid.Rows[r].Cells[c].Style.BackColor = Color.Red;
                        statusGrid.Rows[r].Cells[c].Style.ForeColor = Color.White;
                        statusGrid.Rows[r].Cells[c].Value = "";
                    }
                }
            }));
        }

        private async Task SetupMqttClient()
        {
            try
            {
                if (mqttClient != null)
                {
                    try { await mqttClient.DisconnectAsync(); } catch { }
                    mqttClient = null;
                }

                string host = textBoxBroker.Text;

                mqttClient = new SimpleMqttClient();
                mqttClient.MessageReceived += MqttClient_MessageReceived;
                mqttClient.Disconnected += MqttClient_Disconnected;

                await mqttClient.ConnectAsync(host, 1883, "ScaryHouseClient");

                await mqttClient.SubscribeAsync(new[] { "status/group1", "status/group2", "status/group3", "status/maindoor", "status/eachgate" });

                Invoke(new Action(() => buttonConnect.Text = "Connected"));
                Logger.Log($"Connected to MQTT broker {host}");
            }
            catch (Exception ex)
            {
                MessageBox.Show("MQTT connect failed: " + ex.Message);
                Invoke(new Action(() => buttonConnect.Text = "Connect MQTT"));
                Logger.Log($"MQTT connect failed: {ex.Message}");
            }
        }

        private void MqttClient_Disconnected(Exception ex)
        {
            Invoke(new Action(() => buttonConnect.Text = "Connect MQTT"));
            Logger.Log($"Disconnected from MQTT broker: {ex?.Message ?? "unknown"}");

            if (userRequestedDisconnect) return;

            string host = textBoxBroker.Text;
            _ = Task.Run(async () =>
            {
                while (!userRequestedDisconnect)
                {
                    try
                    {
                        var client = new SimpleMqttClient();
                        client.MessageReceived += MqttClient_MessageReceived;
                        client.Disconnected += MqttClient_Disconnected;
                        await client.ConnectAsync(host, 1883, "ScaryHouseClient");
                        await client.SubscribeAsync(new[] { "status/group1", "status/group2", "status/group3", "status/maindoor", "status/eachgate" });

                        var old = mqttClient; mqttClient = client; try { old?.Dispose(); } catch { }
                        Invoke(new Action(() => buttonConnect.Text = "Connected"));
                        Logger.Log($"Reconnected to MQTT broker {host}");
                        break;
                    }
                    catch { await Task.Delay(5000); }
                }
            });
        }

        private void HandleMainDoorMessage(string payload)
        {
            if (string.IsNullOrWhiteSpace(payload) || payload.Length < 2) return;
            var val = payload.Trim();
            if (val == "00") return;
            if (!int.TryParse(val, out int switchNum)) return;
            if (switchNum < 1 || switchNum > 3) return;

            int row = switchNum - 1;
            int col = 1;
            MarkGridCell(row, col);
            Logger.Log($"MainDoor switch {val} pressed -> Group {row + 1} maingate");
        }

        private void HandleEachGateMessage(string payload)
        {
            if (string.IsNullOrWhiteSpace(payload) || payload.Length < 2) return;
            var val = payload.Trim();
            if (!int.TryParse(val, out int gateNum)) return;
            if (gateNum < 1 || gateNum > 15) return;

            int col = 1 + gateNum;
            for (int r = 0; r < 3; r++) MarkGridCell(r, col);
            Logger.Log($"EachGate event gate {val}");
        }

        private void MarkGridCell(int row, int col)
        {
            if (statusGrid == null) return;
            if (row < 0 || row >= statusGrid.Rows.Count) return;
            if (col < 1 || col >= statusGrid.Columns.Count) return;

            Invoke(new Action(() =>
            {
                var cell = statusGrid.Rows[row].Cells[col];
                cell.Style.BackColor = Color.LimeGreen;
                cell.Style.ForeColor = Color.Black;
                cell.Value = "ON";
            }));

            _ = Task.Run(async () =>
            {
                await Task.Delay(5000);
                Invoke(new Action(() =>
                {
                    try
                    {
                        var cell = statusGrid.Rows[row].Cells[col];
                        cell.Style.BackColor = Color.Red;
                        cell.Style.ForeColor = Color.White;
                        cell.Value = "";
                    }
                    catch { }
                }));
            });
        }

        private void numericTimeout_ValueChanged(object sender, EventArgs e)
        {
            try { offlineTimeout = TimeSpan.FromSeconds((double)numericTimeout.Value); } catch { }
        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            var now = DateTime.UtcNow;
            foreach (var kv in lastSeen.ToList())
            {
                if (now - kv.Value > offlineTimeout)
                {
                    var mac = kv.Key;
                    int battery = lastBattery.ContainsKey(mac) ? lastBattery[mac] : 0;
                    for (int g = 1; g <= 3; g++)
                    {
                        if (groupMappings[g].TryGetValue(mac, out int slot))
                        {
                            int globalIndex = (g - 1) * NodesPerGroup + slot;
                            if (globalIndex >= 0 && globalIndex < nodeLights.Count)
                            {
                                nodeLights[globalIndex].FillColor = Color.Red;
                                batteryLabels[globalIndex].Text = $"HeadSet {slot + 1}: Battery: {battery}% (offline)";
                                nodeLights[globalIndex].Invalidate();

                                if (isOnline.TryGetValue(mac, out bool wasOnline) && wasOnline)
                                {
                                    isOnline[mac] = false;
                                    Logger.Log($"Device {mac} Group {g} HeadSet {slot + 1} OFFLINE battery {battery}%");
                                }
                            }
                        }
                    }
                }
            }
        }

        private void MqttClient_MessageReceived(string topic, byte[] payload)
        {
            try
            {
                string payloadStr = Encoding.UTF8.GetString(payload);

                if (topic.EndsWith("maindoor", StringComparison.InvariantCultureIgnoreCase)) { HandleMainDoorMessage(payloadStr); return; }
                if (topic.EndsWith("eachgate", StringComparison.InvariantCultureIgnoreCase)) { HandleEachGateMessage(payloadStr); return; }

                var parts = payloadStr.Split(new[] { ',', ';', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length < 2) return;
                string mac = parts[0].Trim(); if (mac.Contains(":")) mac = mac.Replace(":" , ""); if (mac.Length == 0) return;
                if (!int.TryParse(parts[1], out int battery)) battery = 0;

                int group = 0;
                if (topic.EndsWith("group1", StringComparison.InvariantCultureIgnoreCase)) group = 1;
                else if (topic.EndsWith("group2", StringComparison.InvariantCultureIgnoreCase)) group = 2;
                else if (topic.EndsWith("group3", StringComparison.InvariantCultureIgnoreCase)) group = 3;
                if (group == 0) return;

                for (int g = 1; g <= 3; g++) if (g != group && groupMappings[g].ContainsKey(mac)) { Logger.Log($"Rejected status from {mac} for group {group} - already assigned to group {g}"); return; }

                if (!groupMappings[group].TryGetValue(mac, out int slotIndex))
                {
                    var used = new HashSet<int>(groupMappings[group].Values);
                    int found = -1;
                    for (int i = 0; i < NodesPerGroup; i++) if (!used.Contains(i)) { found = i; break; }
                    if (found == -1) return;
                    slotIndex = found; groupMappings[group][mac] = slotIndex;
                }

                lastSeen[mac] = DateTime.UtcNow; lastBattery[mac] = battery;
                int globalIndex = (group - 1) * NodesPerGroup + slotIndex;
                if (globalIndex >= 0 && globalIndex < nodeLights.Count)
                {
                    bool wasOnline = false; isOnline.TryGetValue(mac, out wasOnline);
                    Invoke(new Action(() => {
                        nodeLights[globalIndex].FillColor = Color.LimeGreen; nodeLights[globalIndex].Invalidate();
                        batteryLabels[globalIndex].Text = $"HeadSet {slotIndex + 1}: Battery: {battery}%";
                        try { var parent = batteryLabels[globalIndex].Parent; var macLbl = parent.Controls.OfType<Label>().Skip(1).FirstOrDefault(); if (macLbl != null) macLbl.Text = "MAC: " + mac; } catch { }
                    }));
                    if (!wasOnline) { isOnline[mac] = true; Logger.Log($"Device {mac} Group {group} HeadSet {slotIndex + 1} ONLINE battery {battery}%"); }
                }
            }
            catch { }
        }

        private async void buttonConnect_Click(object sender, EventArgs e)
        {
            if (mqttClient != null && mqttClient.IsConnected)
            {
                userRequestedDisconnect = true; await mqttClient.DisconnectAsync(); userRequestedDisconnect = false; buttonConnect.Text = "Connect MQTT"; return;
            }
            await SetupMqttClient();
        }

        private void buttonUpdateConfig_Click(object sender, EventArgs e)
        {
            using (var dlg = new RoomSettingsForm(roomConfig))
            {
                if (dlg.ShowDialog(this) == DialogResult.OK)
                {
                    Logger.Log("Room timers updated"); MessageBox.Show("Room timers saved");
                }
            }
        }

        private async void buttonPub1_Click(object sender, EventArgs e) => await PublishIfConnected("music/group1", "play");
        private async void buttonPub2_Click(object sender, EventArgs e) => await PublishIfConnected("music/group2", "play");
        private async void buttonPub3_Click(object sender, EventArgs e) => await PublishIfConnected("music/group3", "play");

        private async Task PublishIfConnected(string topic, string payload, bool showMessage = true)
        {
            if (mqttClient == null || !mqttClient.IsConnected) { if (showMessage) MessageBox.Show("Not connected to MQTT broker"); return; }
            try { await mqttClient.PublishAsync(topic, Encoding.UTF8.GetBytes(payload)); if (showMessage) MessageBox.Show($"Published to {topic}"); }
            catch (Exception ex) { if (showMessage) MessageBox.Show("Publish failed: " + ex.Message); }
        }

        private void buttonReset_Click(object sender, EventArgs e)
        {
            groupMappings[1].Clear(); groupMappings[2].Clear(); groupMappings[3].Clear(); lastSeen.Clear(); lastBattery.Clear(); isOnline.Clear();
            for (int i = 0; i < nodeLights.Count; i++) { int slot = (i % NodesPerGroup) + 1; nodeLights[i].FillColor = Color.Red; nodeLights[i].Invalidate(); batteryLabels[i].Text = $"HeadSet {slot}: -- | Battery: --%"; try { var parent = batteryLabels[i].Parent; var macLbl = parent.Controls.OfType<Label>().Skip(1).FirstOrDefault(); if (macLbl != null) macLbl.Text = "MAC: --"; } catch { } }
            ResetStatusGridColors(); Logger.Log("Reset all mappings and statuses");
        }
    }

    // CirclePanel draws an anti-aliased filled circle based on FillColor
    internal class CirclePanel : Panel
    {
        public Color FillColor { get; set; } = Color.Red;
        public CirclePanel() { this.SetStyle(ControlStyles.ResizeRedraw | ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint, true); }
        protected override void OnPaint(PaintEventArgs e) { e.Graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias; using (var brush = new SolidBrush(FillColor)) e.Graphics.FillEllipse(brush, 0, 0, Width - 1, Height - 1); using (var pen = new Pen(Color.FromArgb(100, Color.Black))) e.Graphics.DrawEllipse(pen, 0, 0, Width - 1, Height - 1); base.OnPaint(e); }
    }

    // SimpleMqttClient: minimal MQTT client
    internal class SimpleMqttClient : IDisposable
    {
        private TcpClient tcp;
        private NetworkStream stream;
        private CancellationTokenSource readerCts;
        private CancellationTokenSource keepAliveCts;
        private ushort nextPacketId = 1;
        private int keepAliveSeconds = 60;
        private SemaphoreSlim writeLock = new SemaphoreSlim(1, 1);
        public bool IsConnected { get; private set; }
        public event Action<string, byte[]> MessageReceived;
        public event Action<Exception> Disconnected;

        public async Task ConnectAsync(string host, int port, string clientId)
        {
            tcp = new TcpClient(); await tcp.ConnectAsync(host, port); stream = tcp.GetStream();
            var protocolName = Encoding.ASCII.GetBytes("MQTT"); var payloadClientId = Encoding.UTF8.GetBytes(clientId);
            var variableHeader = new List<byte>(); variableHeader.AddRange(EncodeString(protocolName)); variableHeader.Add(0x04); variableHeader.Add(0x02); variableHeader.Add(0); variableHeader.Add((byte)keepAliveSeconds);
            var payload = new List<byte>(); payload.AddRange(EncodeString(payloadClientId));
            var remaining = EncodeRemainingLength(variableHeader.Count + payload.Count);
            var packet = new List<byte>(); packet.Add(0x10); packet.AddRange(remaining); packet.AddRange(variableHeader); packet.AddRange(payload);
            await WriteAsync(packet.ToArray());

            var header = new byte[4]; int read = 0; while (read < 4) { int r = await stream.ReadAsync(header, read, 4 - read); if (r == 0) throw new Exception("Disconnected while waiting CONNACK"); read += r; }
            if (header[0] != 0x20 || header[3] != 0x00) throw new Exception($"CONNACK failed, code={header[3]}");
            IsConnected = true; readerCts = new CancellationTokenSource(); keepAliveCts = new CancellationTokenSource(); _ = Task.Run(() => ReaderLoopAsync(readerCts.Token)); _ = Task.Run(() => KeepAliveLoopAsync(keepAliveCts.Token));
        }

        public async Task SubscribeAsync(string[] topics)
        {
            if (!IsConnected) throw new InvalidOperationException("Not connected"); ushort pid = GetNextPacketId(); var payload = new List<byte>(); foreach (var t in topics) { var tb = Encoding.UTF8.GetBytes(t); payload.AddRange(EncodeString(tb)); payload.Add(0x00); }
            var variable = new List<byte>(); variable.Add((byte)((pid >> 8) & 0xFF)); variable.Add((byte)(pid & 0xFF)); variable.AddRange(payload);
            var remaining = EncodeRemainingLength(variable.Count); var packet = new List<byte>(); packet.Add(0x82); packet.AddRange(remaining); packet.AddRange(variable); await WriteAsync(packet.ToArray());
        }

        private async Task ReaderLoopAsync(CancellationToken ct)
        {
            Exception error = null;
            try
            {
                while (!ct.IsCancellationRequested)
                {
                    var hb = new byte[1]; int r0 = await stream.ReadAsync(hb, 0, 1, ct); if (r0 == 0) break; byte header = hb[0];
                    int mul = 1; int remaining = 0;
                    while (true) { var rbBuf = new byte[1]; int r = await stream.ReadAsync(rbBuf, 0, 1, ct); if (r == 0) throw new Exception("Unexpected EOF"); byte rb = rbBuf[0]; remaining += (rb & 127) * mul; mul *= 128; if ((rb & 128) == 0) break; }
                    var body = new byte[remaining]; int read = 0; while (read < remaining) { int rc = await stream.ReadAsync(body, read, remaining - read, ct); if (rc == 0) throw new Exception("Disconnected"); read += rc; }
                    int packetType = (header >> 4) & 0x0F;
                    if (packetType == 3) { int idx = 0; int topicLen = (body[idx] << 8) | body[idx + 1]; idx += 2; string topic = Encoding.UTF8.GetString(body, idx, topicLen); idx += topicLen; int payloadLen = remaining - idx; var payload = new byte[payloadLen]; Buffer.BlockCopy(body, idx, payload, 0, payloadLen); MessageReceived?.Invoke(topic, payload); }
                }
            }
            catch (Exception ex) { error = ex; }
            finally { IsConnected = false; try { readerCts?.Cancel(); } catch { } try { keepAliveCts?.Cancel(); } catch { } Disconnected?.Invoke(error); }
        }

        private async Task KeepAliveLoopAsync(CancellationToken ct)
        {
            try { int interval = Math.Max(1, keepAliveSeconds / 2); while (!ct.IsCancellationRequested && IsConnected) { await Task.Delay(interval * 1000, ct); if (ct.IsCancellationRequested) break; try { await SendPingAsync(); } catch { } } } catch { }
        }

        private async Task SendPingAsync() { var pkt = new byte[] { 0xC0, 0x00 }; await WriteAsync(pkt); }

        public async Task PublishAsync(string topic, byte[] payload) { if (!IsConnected) throw new InvalidOperationException("Not connected"); var topicBytes = Encoding.UTF8.GetBytes(topic); var variable = EncodeString(topicBytes); var remainingLength = variable.Length + payload.Length; var remaining = EncodeRemainingLength(remainingLength); var packet = new List<byte>(); packet.Add(0x30); packet.AddRange(remaining); packet.AddRange(variable); packet.AddRange(payload); await WriteAsync(packet.ToArray()); }

        public async Task DisconnectAsync() { try { if (!IsConnected) return; var pkt = new byte[] { 0xE0, 0x00 }; await WriteAsync(pkt); await stream.FlushAsync(); } catch { } finally { IsConnected = false; try { readerCts?.Cancel(); } catch { } try { keepAliveCts?.Cancel(); } catch { } try { stream?.Close(); } catch { } try { tcp?.Close(); } catch { } Disconnected?.Invoke(null); } }

        private async Task WriteAsync(byte[] data) { await writeLock.WaitAsync(); try { if (stream == null) throw new InvalidOperationException("Not connected"); await stream.WriteAsync(data, 0, data.Length); await stream.FlushAsync(); } finally { writeLock.Release(); } }

        private ushort GetNextPacketId() { var id = nextPacketId++; if (nextPacketId == 0) nextPacketId = 1; return id; }
        private static byte[] EncodeString(byte[] data) { var len = data.Length; var result = new byte[2 + len]; result[0] = (byte)((len >> 8) & 0xFF); result[1] = (byte)(len & 0xFF); Buffer.BlockCopy(data, 0, result, 2, len); return result; }
        private static byte[] EncodeRemainingLength(int length) { var bytes = new List<byte>(); int x = length; do { byte encoded = (byte)(x % 128); x = x / 128; if (x > 0) { encoded = (byte)(encoded | 128); } bytes.Add(encoded); } while (x > 0); return bytes.ToArray(); }
        public void Dispose() { try { stream?.Dispose(); } catch { } try { tcp?.Dispose(); } catch { } }
    }

    internal static class NetworkStreamExtensions
    {
        public static async Task<int> ReadByteAsync(this NetworkStream stream, CancellationToken ct)
        {
            var buffer = new byte[1];
            try
            {
                int r = await stream.ReadAsync(buffer, 0, 1, ct);
                if (r == 0) return -1;
                return buffer[0];
            }
            catch (OperationCanceledException) { return -1; }
        }
    }

}
